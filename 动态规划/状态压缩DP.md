# 状态表示

利用位运算思想, 有(1<<n)种

例如: n=9. 10101011, 表示取了1,3,5,6,8,9物品.



# 位运算



运算符: &，|，^，~，>>，<<



- c 插入 A ：A |= (1 << c)
- A 删除 c ：A &= ~(1 << c)
- A 置空 ：A = 0



- 并集 ：A | B
- 交集 ：A & B
- 全集 ：(1 << n) - 1
- 补集 ：((1 << n) - 1) ^ A
- 子集 ：(A & B) == B



判断是否是 2 的幂 ：A & (A - 1) == 0

最低位的 1 变为 0 ：n &= (n - 1)

最低位的 1：A & (-A)，最低位的 1 一般记为 lowbit(A)，表示 A 的二进制表达式中最低位的 1 所对应的值。

最高位的 1：

```cpp
int p = lowbit(A)
while(p != A)
{
    A -= p;
    p = lowbit(A);
}
return p;
```

枚举 A 的子集：

```cpp
for(subset = (A - 1) & A; subset != A; subset = (subset - 1) & A)
{
    ...
}
```


枚举全集的子集：

```cpp
for(i = 0; i <= (1 << n) - 1; ++i)
{
    ...
}
```





# 例题



Q: 旅行商问题

用最短的路程把所有地区环游一遍

A: 

dp[s, i] := 已经选过 s 这些点，最后一个点是 i

dp[s, i] = dp[s | (1 << j), j] + w[i, j]; 从 i 点转移到 j 点，这里 j 可能已经在 s 中了



Q: 不同路径Ⅲ

二维方格grid. 20 * 20. 1起始, 2结束, 0空, -1是障碍. 所有的空要走且只能走一次. 问从1到2的不同路径数目.

A:

先求出target: 状压下的所有空白方格.

dp[sr, sc, target] 从(sr, sc)开始行走, 还没有遍历的空格集合为target的好路径的数目.

dp[r, c, k] = 求和( dp[r1, c1, k | (r1,c1)] ) ,  [r1, c1] 为 [r, c]相邻格. (r1, c1) 为 r1,c1的二进制数. k & (r1, c1) == 1.



Q: 划分为k个相等的子集

n个数. 是否能划分为k个相等的子集.

A:

先将数组排序, 单调递增.

target: 每个子集的目标值.

dp[s] - 已选状态为s是否尽量可行    sum[s] - 已选状态为s的和

```cpp
dp[s|(1<<j)] = 1, sum[s|(1<<j)] = sum[s]+num[j];
// s&(1<<j)=0, dp[s]=1, sum[s]%target + nums[j] <= target
```



Q: 按位与为0的三元组

n<=1000, a[i] < 2^16^

A:

先暴力O(n*n)求两个数的和

dp[i] - 两个数可以与出i的方案数 i < 2^16^

对于每个数x, x&y=0 y=(-x)&(0x0000FFFF)

```cpp
int A = y;
for(subset = (A - 1) & A; subset != A; subset = (subset - 1) & A) // 枚举子集
{
    ans += dp[subset];
}
ans += dp[A]; //全集
```







