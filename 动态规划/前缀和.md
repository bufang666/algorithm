# 前缀和简介



给定长度为n的序列a: a0, a1, a2, .... a(n-1) , 对每个前缀求一次和 S0=0, Si=a0+a1+....a(i-1).

两类求和要求

(1) 求前缀和 求a[0..i]的和 -> S[i+1]

(2) 求区间和 求a[L, R]的和 -> S[R+1] - S[L]



# 求区间和

区域和检索 - 数组不可变

求a[L, R]

ANS = S[R+1] - S[L]





二维区域和检索 - 矩阵不可变

求[l1, r1, l2, r2]

S[n, m] = [i 0...n-1] [j, 0...m-1] a[i, j]

ANS = S[l2+1, r2+1] - S[l1, r2+1] - S[l2+1, r2] + S[l1, r1]



# 数据结构维护前缀和









## HashMap 维护 (1)，键是前缀和（状态）的值，值为第一次出现时的索引

和等于 k 的最长子数组长度

给定nums[]和k, 找到和等于k的最长子数组长度

unordered_map <int, int> presum_idx;

键为Si, 值是Si第一次出现的索引







## HashMap 维护 (2)，键是前缀和（前缀状态）的值，值为出现次数

和为 K 的子数组

求个数.

unordered_map <int, int> presum_cnt;

键为Si, 值是Si的出现次数







## HashMap 维护 (3)，键是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模K）

连续的子数组和 —— 值为第一次出现时的索引

给定nums[], k, 求子数组(和=x*k)



和可被 K 整除的子数组 —— 值为出现次

给定nums[],k, 求子数组个数(和=x*k)







## 前缀和（积）与后缀和（积）均需要











## 二维前缀和



元素和为目标值的子矩阵数量

选定i1,i2, 确定上下边界  二维->一维





# 运算推广

区间减法性质 : 区间 A[i, j] B[i, k] C[k+1, j] i<k<j. 有了A,B能求出C.

(1)异或: a=b^c => c=b^a

(2)乘法/模下乘法: a=b*c => c=a/b

所以可推广到前缀异或, 前缀和













# 差分



| 它                | 它的差分序列                       |
| ----------------- | ---------------------------------- |
| 前缀和序列S0,S1.. | 原序列a0,a1,....  ai=S(i+1)-Si     |
| 原序列a0,a1,a2    | b0,b1,b2....    bi=ai-a(i-1),b0=a0 |

若要对原序列[l, r]所有值加val, 在差分序列上只需要b[l]+=val, b[r+1]-=val



区间加法

[l, r, x] - [l, r]+=x

用差分序列加 O(1)