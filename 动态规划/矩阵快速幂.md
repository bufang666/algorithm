# 矩阵快速幂

用于优化组合计数 O(N) --> O(logN)

# 快速幂

x^n^%m

(1)递归写法.

```cpp
ll q_pow(ll x,ll n,ll m){
	if(n == 0)	return 1;
	ll res = q_pow(x * x % m,n/2,m);
	if(n & 1)	res = res * x % m;
	return res;
}
```

(2)非递归写法

```cpp

ll quick_pow(ll x,ll n,ll m){
	ll res = 1;
	while(n > 0){
		if(n & 1)	res = res * x % m;
		x = x * x % m;
		n >>= 1;//相当于n=n/2.详情请参考位移运算符。
	}
	return res;
}
```



# 矩阵快速幂

```cpp
struct Ma {
	int a[M][M];
	MA() {
        mmeset(a, 0, sizeof(a));
    }
    void init() {
        a[0][0] = a[1][1] = 1;
        a[0][1] = a[1][0] = 0;
    }
    
    Ma operator * (const Ma & B) const {
        Ma ans;
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < M; j++) {
                for (int k = 0; k < M; k++) {
                    ans.a[i][j] = a[i][k]*B.a[k][j];
                }
            }
        }
        return ans;
    }
    
    Ma operator ^ (int n) const {
        Ma ans;
        ans.init();
        Ma A = *this;
        while (n) {
            if (n&1) ans = ans*A;
            A = A * A;
            n >>= 1;
        }
        return ans;
    }
    
}
```



# 例题

Q: 爬楼梯 

可以一步/两步

A: 

f[n] = f[n-1] + f[n-2], f[0] = f[1] = 1;

![image-20210720101320251](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20210720101320251.png)

Q: ![image-20210720101339084](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20210720101339084.png)

A:

A = ![image-20210720101404873](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20210720101404873.png)

Q: f[n] = 上面一堆+bn+c

A:

令f[n]+un+v = xigema([i, 1...m],  ai * f[n-i]+u(n-i)+v )

xigema{ [i, 1...m], u(n-i)+v} -un-v = bn+c

