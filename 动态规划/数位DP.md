# 数位DP

数位 DP 主要解决的问题: 在一段区间 [L, R] 上：

1. 满足某些条件的数字个数
2. 将 x∈[L,R] 代到一个函数 f(x) 中，一个数字 x 的 f(x) 值为一次贡献的量，求总的贡献

时间复杂度一般是O(lgL)



DP状态设计: 

dp[pos, lim] - pos 为当前的数位 N-1 ~ 0 ，lim 表示是否顶到上界，pos 到 -1 的时候可以 return 1，使得个位的枚举有效

DP状态转移:

```cpp
dp[pos][lim]: 
dp[pos][0] = 10 * dp[pos - 1][0]
dp[pos][1] = digits[i] * dp[pos - 1][0] + dp[pos - 1][1]

```

前导零会对结果产生影响时，加一维 zero

可能需要带上前缀的某种状态 state，此状态可能影响当前位的枚举，也可能影响当前位枚举的值对答案的贡献







# 满足某些条件的数字个数

Q: 最大为 N 的数字组合

给定集合D, 问可用D写出的<=N的数字的数目

D = {1, 3, 5} 可以写出 111, 135135, 1, 35, 555

A:

```cpp
int getdp(int pos, int lim, const vector<int>& digits, const set<int>& num_set, vector<vector<int>>& dp)
{
    if(pos == -1) return 1;
    if(dp[pos][lim] != -1)
        return dp[pos][lim];
    dp[pos][lim] = 0;
    int up = lim ? digits[pos] : 9; // 当前要枚举到的上界
    for(int i: num_set) // 枚举当前位所有可能数字
    {
        if(i > up)
            break;
        dp[pos][lim] += getdp(pos - 1, lim && i == up, digits, num_set, dp); // 本位被限制且选顶到上界的数字,下一位才被限制
    }
    return dp[pos][lim];
}
```



Q: 对称数

对称不变, 求[L, R]之间的这样的数的个数

A:

D = {0, 1, 8} 采用上题的思路



# 求贡献f(x)

Q: 数字1的个数

求所有<n的数中1出现的个数

A:

```cpp
for (long long i = 1; i <= n; i*=10) {
	ll divider = i*10;
    ans += (n/divider)*i + min(max(n%divider-i+1, 0), i);
    // 第一个表示前面不拉满时贡献, 第二个表示前面拉满时贡献
}
```

 n = 1234.

个位上 ’1’ 的数量 = 1234/10 (对应 1,11,21,...1221) +  min(4,1) (对应 1231) = 124

十位上 ’1’ 的数量 = (1234/100)*10 (对应 10,11,12,...,110,111,...1919) + min(25,10) (对应 1210,1211,...1219) = 130

百位上 ’1’ 的数量 = (1234/1000)*100 (对应 100,101,102,...,199) + min(135,100) (对应1100,1101...1199) = 200

千位上 ’1’ 的数量 = (1234/10000)*10000 + min(235,1000) (对应1000,1001,...1234) = 235

因此，总数 = 124+130+200+235 = 689。

