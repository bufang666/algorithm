# 状态

```
状态定义：	dp[n] := [0..n] 上问题的解
状态转移：	dp[n] = f(dp[n-1], ..., dp[0])
```

# 单串问题

状态一般定义为 dp[i] := 考虑[0..i]上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：

- 第一种是 i 位置必须取，此时状态可以进一步描述为 dp[i] := 考虑[0..i]上，且取 i，原问题的解；
- 第二种是 i 位置可以取可以不取

## 最经典单串 LIS 系列

Q：最长上升子序列

A1 : DP O(N^2^)

定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度.注意 nums[i] 必须被选中

dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]

LIS~length~=max(dp[i]), 其中0≤*i*<*n*

A2：贪心 + 二分查找  O（NlogN）

我们维护一个数组 d[i]*d*[*i*] ，表示长度为 i*i* 的最长上升子序列的末尾元素的最小值，关于i递增.

设当前已求出的最长上升子序列的长度为 \textit{len}len（初始时为 11），从前往后遍历数组 \textit{nums}nums，在遍历到 \textit{nums}[i]nums[i] 时：

如果 \textit{nums}[i] > d[\textit{len}]nums[i]>d[len] ，则直接加入到 dd 数组末尾，并更新 \textit{len} = \textit{len} + 1len=len+1；

否则，在 dd 数组中二分查找，找到第一个比 \textit{nums}[i]nums[i] 小的数 d[k]d[k] ，并更新 d[k + 1] = \textit{nums}[i]d[k+1]=nums[i]。



Q：最长上升子序列的个数

A1：DP

假设对于以 nums[i] 结尾的序列，我们知道最长序列的长度 length[i]，以及具有该长度的序列的 count[i]。
对于每一个 i<j 和一个 A[i]<A[j]，我们可以将一个 A[j] 附加到以 A[i] 结尾的最长子序列上。
如果这些序列比 length[j] 长，那么我们就知道我们有count[i] 个长度为 length 的序列。如果这些序列的长度与 length[j] 相等，那么我们就知道现在有 count[i] 个额外的序列（即 count[j]+=count[i]）。



A2: 线段树



俄罗斯套娃信封问题

排序 + 最长递增子序列

在对信封按 `w` 进行排序以后，我们可以找到 `h` 上最长递增子序列的长度。



## 最大子数组和系列

最大子序和

求具有最大和的连续子数组

dp[i]表示[0..i]选 i, 以 i 结尾的最大子序和.

dp[i] = max(dp[i-1], 0) + num[i]



乘积最大子组数

乘积最大的连续子数组

maxF[i] 表示以第 i 个元素结尾的乘积最大子数组的乘积

minF[i] 表示以第 i 个元素结尾的乘积最小子数组的乘积

maxF[i] = max(maxF[i - 1] * nums[i], max(nums[i], minF[i - 1] * nums[i]));
        minF[i] = min(minF[i - 1] * nums[i], min(nums[i], maxF[i - 1] * nums[i]));



环形子数组的最大和

最大和具有两种可能，一种是不使用环的情况，另一种是使用环的情况

不使用环的情况时，直接通过53题的思路，逐步求出整个数组中的最大子序和即可

使用到了环,用整个数组的和 sum减掉最小子序和.





最大子矩阵

选定子矩阵上边界L, 下边界R, 压缩二维到一维. 然后求最大子序和.



矩形区域不超过 K 的最大数值和

选定子矩阵上边界L, 下边界R, 压缩二维到一维. 然后求不超过K的最大子序和.



## 打家劫舍系列

打家劫舍

不能选相邻的最大子数组和.

dp[i] 表示 [0...i] 选第 *i* 个元素的原问题的解.

dp[i] = nums[i] + max{dp[i - 2], dp[i - 3]}



打家劫舍 II

环形版打家劫舍

两种情况.

(1)不偷最后一家, [0...n-2]随便打劫

(2)不偷第一家, [1...n-1] 随便打劫



删除与获得点数

选择x,  删除所有等于x-1,x+1元素.

f[i] - 用值 i 得到的最大分数

g[i] - 不用值 i 得到的最大分数

f[i] = g[i-1] + cnt[i]*i

g[i] = max(f[i-1], g[i-1])



3n 块披萨

环形3n块披萨, 选择第 i 块, Alice拿左, bob拿右. 使自己拿的最多.

问题等价于 (数学归纳法) 给定3n环形数组,选择n个不相邻的数, 使最大.

先求普通3n数组情况.

dp[i, j] - 前 i 个数 选择了 j 个数的最大和.

dp[i, j] = max( dp[i - 2, j - 1] + slice[i], dp[i - 1, j] );

(1)不选第一个 wk(1, 3n-1) 

(2)不选最后一个 wk(0, 3n-2)

两个求max



## 变形，需要两个位置的情况: dp[i][j] 以 j, i 结尾

最长的斐波那契子序列的长度 

dp[j, i] 以(num[i], num[j]) 作为结尾的斐波那契子序列的最长长度

dp[j, i] = dp[i, k] + 1 , num[i] + num[k] = num[j], k < i < j, 可利用map求k



最长等差数列

dp[i, j] 以(num[i], num[j])作为结尾的等差数列的最长长度

dp[i, j] = dp[k, i] + 1,  2num[i] = num[j] + num[k], k < i < j, 可利用map求k





## 与其它算法配合

形成字符串的最短路径 

用最少次数的source构成target

贪心, 能用就用.





最大整除子集

先排序

f[i] - [0...i] 选第 i 个数的最大整除子集的大小

f[i] = max{ f[j] } + 1, nums[i] % nums[j] == 0







## 其它单串 dp[i] 问题

最长有效括号

dp[i] - [0...i] 选第 i 个东西的使合法的子序列的最大长度

dp[i] = max ( dp[i], dp[i-1] + 2)

dp[i] = max ( dp[i], dp[i] + dp[i - dp[i]])





等差数列划分

求连续等差数组个数

dp[i] - [0...i] 选第 i 个数的等差数组的个数

dp[i] = dp[i - 1] + 1, if 2nums[i - 1] = nums[i] + nums[i-2]





使序列递增的最小交换次数

两个序列A,B

f[i]  A, B 满足前 i 个元素递增, 且 A[i], B[i] 交换使得合法的最小交换次数.

g[i]  A, B 满足前 i 个元素递增, 且 A[i], B[i] 不交换使得合法的最小交换次数.

f[i], g[i] <- f[i-1], g[i-1] 不同的小于条件







最低加油次数

dp[i] 加 i 次油能走的最远距离

dp[t+1] = dp[t] + cap[i], 若dp[t] >= location[i]

(堆) 用堆存储可用的加油站.

一站一站走,有力气就一直向前, 力气不够就从"大根堆"加堆顶的油.





## 带维度单串 dp[i ] [k]

通常用 k 表示，k 随着题目的不同，可以表示长度，个数，次数，颜色等，同时 k 这个维度的枚举和转移可能涉及到二分，贪心等算法。

最大平均值和的分组 —— k 是个数

f[i, k] 表示数组[0...i]上分成k个的最大分数

f[i, k] = max{ dp[j, k] + sum(j+1, i) } , j < i



鸡蛋掉落 —— k 是次数，k 上有二分

A1: dp+二分 dp[k, n]  原问题的解

dp[k, n] = 1 + min{ max ( dp[k-1, x-1], dp[k, n-1] ) } ,1<=x<=n

dp[k-1, x-1] 关于x递增, dp[k, n-1] 关于x递减, 可用二分求出最小点



A2: DP+决策单调性 

设xopt是使得最优值的决策点x0.

固定k, 随着n递增, dp[k-1, x-1]不变, dp[k, n-x]递增. 所以xopt递增.



A3: 数学-逆向思维

做t次操作, k个鸡蛋, 能找到的最高n是多少?

f[t, k] - 这个问题的解

f[t, k] = 1 + f[t-1, k-1] + f[t-1, k]

在某层碎, 下面有f(t-1, k-1)层; 在某层不碎, 上面有f(t-1, k)层.





# 双串问题

dp[i, j] - s1考虑[0...i], s2考虑[0...j]时原问题的解

dp[i, j] = f( dp[i-1, j], dp[i-1, j-1], dp[i, j-1] )

## 最经典双串 LCS 系列

最长公共子序列 LCS

dp[i, j] s1考虑[0...i], s2考虑[0...j]时LCS

若s1[i] == s2[j] dp[i, j] = dp[i-1, j-1] + 1

若s1[i] != s2[j], dp[i, j] = max{ dp[i-1, j], dp[i, j-1]}

 



两个字符串的最小 ASCII 删除和 —— LCS，len 和 ascii 各一个 dp

同LCS.



## 字符串匹配系列

通配符匹配

字符串s, p. p含'?' 匹配任何单个字符 , '*' 匹配任意字符串(含空串)

dp[i, j] = 1, 即分别考虑[0...i] [0...j] 是匹配的

dp[i, j] = (si == pj) && dp[i-1, j-1]  , pj是字符

​				dp[i-1, j-1], pj = '?'

​				dp[i, j-1]||dp[i-1, j], pj = '*'





正则表达式匹配

字符串s, p. p含'.'匹配任何单个字符, '*'匹配0个或多个前面的那一个元素

dp[i, j] = 1, 即分别考虑[0...i] [0...j] 是匹配的

if (p[j] !=  '*') 

​	dp[i, j] = dp[i-1, j-1] ,matches(si, pj)

​	dp[i,j] = false, otherwise

else 

​	dp[i, j] = dp[i-1, j] || dp[i, j-2] ,matches(si, p(j-1))

​	dp[i, j] = dp[i, j-2], otherwise



## 其它双串 dp[i][j] 问题

交错字符串

s = s1+s2+s3+.....  t = t1+t2+t3+...  ans = s1+t1+s2+t2+.../ t1+s1+t2+s2+...

f[i, j] 表示s的前i个元素和t的前j个元素是否能交错组成ans的前i+j个元素

f[i, j] = ( f[i-1, j] && s[i-1]==ans[p]) or (f[i, j-1] && t[j-1] ==ans[p]) ,  p = i+j-1





不同的子序列

计算s的子序列中t出现的个数

f[i, j] - s[i...] 的子序列中 t[j...]出现的个数

f[i, j] = dp[i+1, j-1] + dp[i+1, j] ,  s[i] == t[j]

f[i, j] = dp[i+1, j] , otherwise





## 带维度双串 dp[i, j, k]

扰乱字符串

(1)s=x+y (2)s=x+y/y+x (3)分别对x, y处理.

问s1与s2是否匹配

f[i, j, k] - s1的[i, i+k-1]与s2的[j, j+k-1]匹配

f[i, j, k] = or { f[i, j+k-k1, k1] and f[i+k1, j, k-k1] } , 1<=k1<k

f[i, j, k] = or { f[i, j, k1] and f[i+k-k1, j+k-k1, k-k1] } , 1<=k1<k





# 矩阵问题

## 矩阵 dp[i] [j]  



最小路径和

矩阵m * n , 只能 向右向下

dp[i, j] 考虑[0...i, 0...j]时原问题的解

dp[i, j] = min(dp[i, j-1], dp[i-1, j]) + nums[i, j]











地下城游戏

矩阵m*n , 只能向右向下, 若血为0或以下必死. 问最少的初始血是多少?

dp[i, j] (i, j) 到终点所需的最小初始血

dp[i, j] = max { min(dp[i+1, j], dp[i, j+1]) - nums[i, j] ,   1}





## 矩阵 dp[i] [j] [k] 

最大矩形

01矩阵,求只含1的最大矩形

单调栈.



最大子矩阵 —— 思路类似一维的最大子数组和

选定上下边界L, R, 二维 -> 一维, 求最大子序和



# 无串线性问题

只有两个键的键盘

开始一个A, 可以COPY/PASTE. 求最少次数打出n个A

最终的操作为 " QAA..." " QAA...." "QAA...."

完成每一组分别有g1, g1 * g2, ...., g1 * g2 *.. *gn 个 A

分解n为g1 * g2 * .... 

g1 = p * q 是否分解? pq >= p+q <=> p>=2 && q>=2