# 队列

队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。

先进先出（first in first out）表.

```cpp
queue <int> q;
//元素访问
int x = q.front(), y = q.back();
//容量
int n = q.size();
q.empty();
//修改
q.push(x);
q.pop();
//其他运算符


```



## 队列模拟

### 数组模拟队列

```cpp
int q[SIZE], ql = 1, qr;
```

- 插入元素：`q[++qr]=x;`
- 删除元素：`++ql;`
- 访问队首/队尾：`q[ql]`/`q[qr]`
- 清空队列：`ql=1;qr=0;`



### 双栈模拟队列

使用两个栈 F,S 模拟一个队列，其中 F 是队尾的栈，S 代表队首的栈，支持 push（在队尾插入），pop（在队首弹出）操作：

- push：插入到栈 F 中。
- pop：如果 S 非空，让 S 弹栈；否则把 F 的元素倒过来压到 S 中（其实就是一个一个弹出插入，做完后是首位颠倒的），然后再让 S 弹栈。

容易证明，每个元素只会进入/转移/弹出一次，均摊复杂度 O(1) 。



## 特殊的队列

### 双端队列

双端队列是指一个可以在队首/队尾插入或删除元素的队列。相当于是栈与队列功能的结合。

双端队列支持的操作有 4 个：在队首 / 队尾 插入 / 删除一个元素

```cpp
deque <int> q;
//元素访问
int x = q.front(), y = q.back();

//容量
if (!q.empty()) {	//返回是否为空

}
int n = q.size();	//返回元素数量

//修改
q.push_back(100);	//队尾插入
q.pop_back();	//队尾删除
q.push_front(100);	//队首插入
q.pop_front();	//队首删除


```



### 循环队列

使用数组模拟队列会导致一个问题：随着时间的推移，整个队列会向数组的尾部移动，一旦到达数组的最末端，即使数组的前端还有空闲位置，再进行入队操作也会导致溢出（这种数组里实际有空闲位置而发生了上溢的现象被称为“假溢出”）。

解决假溢出的办法是采用循环的方式来组织存放队列元素的数组，即将数组下标为 0 的位置看做是最后一个位置的后继。（数组下标为 `x` 的元素，它的后继为 `(x + 1) % SIZE`）。这样就形成了循环队列。



# 优先队列

`priority_queue<int > a;`

```
top 访问队头元素
empty 队列是否为空
size 返回队列内元素个数
push 插入元素到队尾 (并排序)
emplace 原地构造一个元素并插入队列
pop 弹出队头元素
swap 交换内容
```



## 大小根堆

```cpp
//升序队列，小顶堆
priority_queue <int,vector<int>,greater<int> > q;
//降序队列，大顶堆
priority_queue <int,vector<int>,less<int> >q;

//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）
```



## 自定义类型

```cpp
//方法1
struct tmp1 //运算符重载<
{
    int x;
    tmp1(int a) {x = a;}
    bool operator<(const tmp1& a) const
    {
        return x < a.x; //大顶堆
    }
};

//方法2
struct tmp2 //重写仿函数
{
    bool operator() (tmp1 a, tmp1 b)
    {
        return a.x < b.x; //大顶堆
    }
};

priority_queue<tmp1, vector<tmp1>, tmp2> f;
```



Q: [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/)

​	给定nums[] 和 大小为k的滑动窗口. 一直滑动, 求每一个滑动窗口的最大值.

A: O(nlogn)

使用大根堆存储二元组( num, index) : 元素num在数组中下标为index.

每次先插入新元素, 然后看堆顶是否出窗口了.





# 单调队列



"单调" 指的是元素的的 "规律"——递增（或递减）

"队列" 指的是元素只能从队头和队尾进行操作



Q: [滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/)

​	给定nums[] 和 大小为k的滑动窗口. 一直滑动, 求每一个滑动窗口的最大值.

A: O(n)

如果当前的滑动窗口中有下标i j, 只要i<j, nums[i]<=nums[j], 那么只要 i 还在窗口中，那么 j 一定也还在窗口中. 由于 nums[j] 的存在，num[i] 一定不会是滑动窗口中的最大值了, 可以将nums[i] 永久移除.

单调队列为 单调递减的.

维护: 先把超过k限制的队首移除, 然后把值<=新元素的队尾门移除, 然后插入新元素.

每次的队首即为滑动窗口最大值.

