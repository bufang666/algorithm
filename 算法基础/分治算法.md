# 分治算法

分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。

求出子问题的解，就可得到原问题的解。

例: 二分法检索, 归并排序



分治法三步骤

1. 分解, 将要解决的问题划分成若干规模较小的同类问题；
2. 求解, 当子问题划分得足够小时，用较简单的方法解决；
3. 合并, 按原问题的要求，将子问题的解逐层合并构成原问题的解。



# 例题

Q: 寻找两个正序数组的中位数

A:

寻找中位数 --> 寻找第k小数

```cpp
int work(A[], B[], int k) {
	if (k == 1) return min( A[0], B[0]);
    int i = k/2;
    if (A[i] < B[i]) 
        	return work( A+i+1, B, k-i);
    else 
        	return work( A, B+i+1, k-i);
	// 注意查看A,B是否len<k, 此时i要变成len
}
```



Q: 归并排序求逆序对

A:

```cpp
int MergeSort(vector<int>& nums, vector<int> &copy, int start, int end)
{
    if (start == end)
    {
        copy[start] = nums[start];
        return 0;
    }
    int len = (end - start) / 2;
    int left = MergeSort(nums, copy, start, start + len);
    int right = MergeSort(nums, copy, start + len + 1, end);
    int i = start, j = start + len + 1, index = start;
    int cnt = 0;
    while (i <= start + len && j <= end)
    {
        if (nums[i] < nums[j])
        {
            copy[index] = nums[i];
            i++;
        }
        else
        {
            copy[index] = copy[j];
            j++;
            cnt += start + len - i + 1;//次数统计逆序对
        }
        index++;
    }
    while (i <= start + len)//如果前半段有剩余则复制到copy数组中
    {
        copy[index] = nums[i];
        ++i;
        ++index;
    }
    while (j <= end)//如果后半段有剩余则复制到copy数组中
    {
        copy[index] = nums[j];
        ++j;
        ++index;
    }
    for (int i = start;i <= end;i++)//此时copy数组已经有序，将其复制到原数组中
        nums[i] = copy[i];
    return left + right + cnt;
}
```



