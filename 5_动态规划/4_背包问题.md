

# 01背包问题

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

A1: 

```cpp
f[i, v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。

f[i, v]=max{f[i-1, v],f[i-1, v-c[i]]+w[i]}
```

A2:

优化空间复杂度

```cpp
procedure ZeroOnePack(cost,weight)
    for v=V..cost
        f[v]=max{f[v],f[v-cost]+weight}

for i=1..N
    ZeroOnePack(c[i],w[i]);
```



# 完全背包问题

有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

```cpp
procedure CompletePack(cost,weight)
    for v=cost..V
        f[v]=max{f[v],f[v-c[i]]+w[i]}
```

# 多重背包问题

有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

"拆分物品思想"

将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。

转化为了01背包.

```cpp
procedure MultiplePack(cost,weight,amount)
    if cost*amount>=MAXV
        CompletePack(cost,weight)
        return
    integer k=1
    while k<amount
        ZeroOnePack(k*cost,k*weight)
        amount=amount-k
        k=k*2
    ZeroOnePack(amount*cost,amount*weight)
```



# 混合三种背包问题

有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。

```cpp
for i=1..N
    if 第i件物品属于01背包
        ZeroOnePack(c[i],w[i])
    else if 第i件物品属于完全背包
        CompletePack(c[i],w[i])
    else if 第i件物品属于多重背包
        MultiplePack(c[i],w[i],n[i])
```



# 二维费用的背包问题

对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。

设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。

```
f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}
```

| 背包类型 |                                    |
| -------- | ---------------------------------- |
| 01背包   | 可以只使用二维的数组, 倒序遍历v,u  |
| 完全背包 | 采用顺序遍历                       |
| 多重背包 | "拆分物品", 转换为01背包与完全背包 |

Q: 物品总个数的限制, 最多只能取M件物品。

A: 每个物品的件数限制是1. 件数容量为M.



# 分组背包问题

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

设f[k, v]表示前k组物品花费费用v能取得的最大权值

```
for 所有的组k
    for v=V..0
        for 所有的i属于组k
            f[v]=max{f[v],f[v-c[i]]+w[i]}
```



# 有依赖的背包问题

"依赖关系" : i依赖于j，表示若选物品i，则必须选物品j。

"森林"关系.

若a被b,c依赖, 则可以拆成四个物品. {a}, {a, b}, {a, c}, {a, b, c}

每个主件及其附件集合 <==> 一个物品组 < ==>一个泛化物品。



# 泛化物品

在背包容量为V的背包问题中，一个泛化物品就是一个数组h[0..V]，给它费用v，可得到价值h[v]。

Q: 泛化物品的和.两个泛化物品h和l求最大价值.

A: f(v)=max{h(k)+l(v-k)|0<=k<=v}



一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。

而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。



# 背包问题问法的变化

## 输出方案

以01背包为例，方程为

```
f[i, v]=max{f[i-1, v],f[i-1, v-c[i]]+w[i]}.
```

设g[i, v]=0表示推出f[i, v]的值时是采用了方程的前一项（也即f[i, v]=f[i-1, v]），g[i, v]表示采用了方程的后一项。

```cpp
i=N
v=V
while(i>0)
    if(g[i][v]==0)
        print "未选第i项物品"
    else if(g[i][v]==1)
        print "选了第i项物品"
        v=v-c[i]
```



## 输出字典序最小的最优方案

先把物品逆序排列一下. 

从N到1输入时，如果f[i, v]==f[i-1, i-v] , f[i, v] ==f[i-1, f-c[i]]+w[i]同时成立，应该按照后者（即选择了物品i）来输出方案。



## 求方案总数

```
h[i][v]=sum{h[i-1][v],h[i][v-c[i]]}
```



## 最优方案的总数

这里的最优方案是指物品总价值最大的方案。

g[i, v]表示这个子问题的最优方案的总数

```cpp
for i=1..N
   for v=0..V
        f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
        g[i][v]=0
        if(f[i][v]==f[i-1][v])
            inc(g[i][v],g[i-1][v])
        if(f[i][v]==f[i-1][v-c[i]]+w[i])
            inc(g[i][v],g[i-1][v-c[i]])
```



## 求次优解、第K优解

f[i, v] 表示前i个物品、背包大小为v的前k优数组.

f[i, v, k] 表示前i个物品、背包大小为v时，第k优解的值.

f[i, v]这个有序队列是由f[i-1, v]和f[i-1, v-c[i]]+w[i]这两个有序队列合并得到的, 合并这两个有序队列并将结果的前K项储存到f[i, v, 1..K]中