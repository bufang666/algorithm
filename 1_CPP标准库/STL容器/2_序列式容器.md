# 序列式容器

# 简介

- **向量**(`vector`) 后端可高效增加元素的顺序表。
- **数组**(`array`)**C++11**，定长的顺序表，C 风格数组的简单包装。
- **双端队列**(`deque`) 双端都可高效增加元素的顺序表。
- **列表**(`list`) 可以沿双向遍历的链表。
- **单向列表**(`forward_list`) 只能沿一个方向遍历的链表。

# vector

`std::vector` 是 STL 提供的 **内存连续的**、**可变长度** 的数组（亦称列表）数据结构。能够提供线性复杂度的插入和删除，以及常数复杂度的随机访问。

## 构造函数

```cpp
// 1. 创建空vector; 常数复杂度
vector<int> v0;

// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度
v0.reserve(3);

// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度
vector<int> v1(3);

// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度
vector<int> v2(3, 2);

// 4. 创建一个初始空间为3的vector，其元素的默认值是1，
// 并且使用v2的空间配置器; 线性复杂度
vector<int> v3(3, 1, v2.get_allocator());

// 5. 创建一个v2的拷贝vector v4， 其内容元素和v2一样; 线性复杂度
vector<int> v4(v2);

// 6. 创建一个v4的拷贝vector v5，其内容是{v4[1], v4[2]}; 线性复杂度
vector<int> v5(v4.begin() + 1, v4.begin() + 3);

// 7. 移动v2到新创建的vector v6，不发生拷贝; 常数复杂度; 需要 C++11
vector<int> v6(std::move(v2));  // 或者 v6 = std::move(v2);
```



## 元素访问

```cpp
at()

v.at(pos) 返回容器中下标为 pos 的引用。如果数组越界抛出 std::out_of_range 类型的异常。

operator[]

v[pos] 返回容器中下标为 pos 的引用。不执行越界检查。

front()

v.front() 返回首元素的引用。

back()

v.back() 返回末尾元素的引用。

data()

v.data() 返回指向数组第一个元素的指针。
```



## 迭代器

```cpp
begin()/cbegin()

返回指向首元素的迭代器，其中 *begin = front。

end()/cend()

返回指向数组尾端占位符的迭代器，注意是没有元素的。

rbegin()/rcbegin()

返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。

rend()/rcend()

返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。

以上列出的迭代器中，含有字符 c 的为只读迭代器，
```



## 长度和容量

```cpp
// 长度
empty() 返回一个 bool 值，即 v.begin() == v.end()，true 为空，false 为非空。

size() 返回容器长度（元素数量），即 std::distance(v.begin(), v.end())。

resize() 改变 vector 的长度，多退少补。补充元素可以由参数指定。

max_size() 返回容器的最大可能长度。

// 容量
reserve() 使得 vector 预留一定的内存空间，避免不必要的内存拷贝。

capacity() 返回容器的容量，即不发生拷贝的情况下容器的长度上限。

shrink_to_fit() 使得 vector 的容量与长度一致，多退但不会少。

```



## 元素增删及修改

```cpp
clear() 清除所有元素
insert() 支持在某个迭代器位置插入元素、可以插入多个。复杂度与 pos 距离末尾长度成线性而非常数的
erase() 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 insert 一致。
push_back() 在末尾插入一个元素，均摊复杂度为 常数，最坏为线性复杂度。
pop_back() 删除末尾元素，常数复杂度。
swap() 与另一个容器进行交换，此操作是 常数复杂度 而非线性的。
```



# deque

双端队列.

## 构造函数

```cpp
// 1. 定义一个int类型的空双端队列 v0
deque<int> v0;

// 2. 定义一个int类型的双端队列 v1，并设置初始大小为10; 线性复杂度
deque<int> v1(10);

// 3. 定义一个int类型的双端队列 v2，并初始化为10个1; 线性复杂度
deque<int> v2(10, 1);

// 4. 复制已有的双端队列 v1; 线性复杂度
deque<int> v3(v1);

// 5. 创建一个v2的拷贝deque v4，其内容是v4[0]至v4[2]; 线性复杂度
deque<int> v4(v2.begin(), v2.begin() + 3);

// 6. 移动v2到新创建的deque v5，不发生拷贝; 常数复杂度; 需要 C++11
deque<int> v5(std::move(v2));
```



## 元素访问

```cpp
at() 返回容器中指定位置元素的引用，执行越界检查，常数复杂度。
operator[] 返回容器中指定位置元素的引用。不执行越界检查，常数复杂度。
front() 返回首元素的引用。
back() 返回末尾元素的引用。
```



## 迭代器

与 `vector` 一致。

## 长度

与 `vector` 一致，但是没有 `reserve()` 和 `capacity()` 函数。



## 元素增删及修改

与 `vector` 一致，并额外有向队列头部增加元素的函数。

```cpp
clear() 清除所有元素
insert() 支持在某个迭代器位置插入元素、可以插入多个。复杂度与 pos 与两端距离较小者成线性。
erase() 删除某个迭代器或者区间的元素，返回最后被删除的迭代器。复杂度与 insert 一致。
push_front() 在头部插入一个元素，常数复杂度。
pop_front() 删除头部元素，常数复杂度。
push_back() 在末尾插入一个元素，常数复杂度。
pop_back() 删除末尾元素，常数复杂度。
swap() 与另一个容器进行交换，此操作是 常数复杂度 而非线性的。
```

